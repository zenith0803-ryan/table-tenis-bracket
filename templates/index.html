<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <title>üèì ÌÉÅÍµ¨ ÎåÄÏßÑÌëú</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f0f0f0; color: #333; }
    #app { max-width: 480px; margin: 0 auto; min-height: 100vh; background: #fff; }

    /* Header */
    .header { background: #e74c3c; color: #fff; padding: 14px 16px; display: flex; align-items: center; justify-content: space-between; }
    .header h1 { font-size: 17px; font-weight: 700; }
    .header-right { display: flex; align-items: center; gap: 8px; }
    .room-chip { font-size: 12px; background: rgba(255,255,255,0.25); padding: 2px 8px; border-radius: 10px; letter-spacing: 1px; }
    .icon-btn { background: none; border: none; color: #fff; font-size: 20px; cursor: pointer; padding: 2px; }

    /* Content */
    .content { padding: 16px; }

    /* Buttons */
    .btn { display: block; width: 100%; padding: 13px; border: none; border-radius: 8px; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity .15s; }
    .btn:active { opacity: .75; }
    .btn-primary { background: #e74c3c; color: #fff; }
    .btn-secondary { background: #f0f0f0; color: #333; }
    .btn-sm { display: inline-block; width: auto; padding: 9px 16px; font-size: 14px; }

    /* Option buttons */
    .option-group { display: flex; gap: 8px; flex-wrap: wrap; }
    .opt-btn { flex: 1; min-width: 70px; padding: 10px 6px; border: 2px solid #ddd; border-radius: 8px; background: #fff; text-align: center; font-size: 14px; font-weight: 500; cursor: pointer; transition: all .15s; }
    .opt-btn.active { border-color: #e74c3c; background: #fef0ee; color: #e74c3c; }

    /* Form */
    .form-group { margin-bottom: 16px; }
    label { display: block; font-size: 13px; font-weight: 600; color: #666; margin-bottom: 6px; }
    input[type="text"], input[type="number"], select {
      width: 100%; padding: 11px 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 15px;
    }
    input:focus, select:focus { outline: none; border-color: #e74c3c; }

    /* Tabs */
    .tabs { display: flex; border-bottom: 2px solid #eee; }
    .tab { flex: 1; padding: 11px; text-align: center; font-size: 14px; font-weight: 500; color: #aaa; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -2px; }
    .tab.active { color: #e74c3c; border-bottom-color: #e74c3c; }

    /* Round label */
    .round-label { font-size: 11px; font-weight: 700; color: #aaa; text-transform: uppercase; letter-spacing: .5px; margin: 16px 0 8px; }

    /* Match card */
    .match-card { background: #f7f7f7; border-radius: 10px; padding: 13px; margin-bottom: 8px; cursor: pointer; border: 2px solid transparent; transition: border-color .15s; }
    .match-card:active { opacity: .8; }
    .match-card.done { border-color: #27ae60; background: #f0faf4; }
    .match-card.bye { cursor: default; opacity: .55; }
    .match-card.pending { cursor: default; opacity: .6; }
    .match-players { display: flex; align-items: center; gap: 6px; }
    .mp { flex: 1; font-size: 15px; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .mp.right { text-align: right; }
    .mp.winner { color: #27ae60; }
    .match-vs { color: #aaa; font-size: 13px; flex-shrink: 0; }
    .match-sets { display: flex; gap: 4px; justify-content: center; flex-wrap: wrap; margin-top: 6px; }
    .set-pill { background: #ddd; border-radius: 4px; padding: 2px 6px; font-size: 11px; color: #555; }
    .set-pill.w { background: #27ae60; color: #fff; }
    .ref-note { font-size: 11px; color: #aaa; margin-top: 5px; }
    .ref-badge { background: #f39c12; color: #fff; border-radius: 4px; padding: 1px 5px; font-size: 10px; font-weight: 600; margin-left: 4px; }

    /* Winner banner */
    .winner-banner { background: linear-gradient(135deg,#f39c12,#e74c3c); color: #fff; border-radius: 12px; padding: 16px; text-align: center; margin-bottom: 16px; }
    .winner-banner .trophy { font-size: 34px; }
    .winner-banner .wname { font-size: 22px; font-weight: 700; margin: 4px 0; }
    .winner-banner .wlabel { font-size: 13px; opacity: .9; }

    /* Bracket */
    .bracket-wrap { overflow-x: auto; padding-bottom: 12px; }
    .bracket-rounds { display: flex; gap: 12px; min-width: max-content; padding: 4px 0; }
    .bracket-col { display: flex; flex-direction: column; gap: 10px; min-width: 140px; }
    .bracket-col-label { font-size: 11px; font-weight: 700; color: #aaa; text-align: center; text-transform: uppercase; margin-bottom: 2px; }
    .bracket-match { background: #f7f7f7; border-radius: 8px; padding: 9px 10px; border: 1px solid #e0e0e0; }
    .bracket-match.done { border-color: #27ae60; }
    .bp { font-size: 12px; font-weight: 500; padding: 2px 0; }
    .bp.winner { color: #27ae60; font-weight: 700; }
    .bp.bye { color: #ccc; font-style: italic; }
    .bp.pending { color: #ccc; }
    .bdivider { border: none; border-top: 1px solid #e8e8e8; margin: 3px 0; }

    /* Standings */
    .standings-table { width: 100%; border-collapse: collapse; font-size: 14px; }
    .standings-table th { text-align: left; padding: 8px 6px; border-bottom: 2px solid #eee; font-size: 12px; color: #999; }
    .standings-table td { padding: 10px 6px; border-bottom: 1px solid #f0f0f0; }
    .standings-table tr:last-child td { border-bottom: none; }
    .rank { font-weight: 700; color: #e74c3c; width: 22px; }

    /* Info */
    .info-box { background: #f7f7f7; border-radius: 10px; padding: 14px; margin-bottom: 12px; }
    .info-box h3 { font-size: 13px; font-weight: 700; color: #888; margin-bottom: 10px; }
    .info-row { display: flex; justify-content: space-between; font-size: 14px; padding: 6px 0; border-bottom: 1px solid #eee; }
    .info-row:last-child { border-bottom: none; }
    .info-val { font-weight: 600; }
    .room-code-big { font-size: 30px; font-weight: 700; letter-spacing: 5px; text-align: center; color: #e74c3c; background: #fef0ee; border-radius: 8px; padding: 12px; margin-bottom: 6px; }

    /* Players screen */
    .player-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
    .player-num { font-size: 13px; font-weight: 700; color: #aaa; min-width: 22px; }

    /* Team builder */
    .team-card { background: #f7f7f7; border-radius: 10px; padding: 12px; margin-bottom: 10px; }
    .team-card h4 { font-size: 13px; font-weight: 700; color: #888; margin-bottom: 8px; }
    .team-selects { display: flex; gap: 8px; align-items: center; }
    .team-selects select { flex: 1; padding: 8px; font-size: 14px; border: 1px solid #ddd; border-radius: 6px; }

    /* Setup hero */
    .hero { text-align: center; padding: 28px 0 20px; }
    .hero-icon { font-size: 64px; margin-bottom: 8px; }
    .hero-title { font-size: 20px; font-weight: 700; margin-bottom: 4px; }
    .hero-sub { font-size: 14px; color: #aaa; }

    /* Divider */
    .divider { border: none; border-top: 1px solid #eee; margin: 18px 0; }
    .or-row { display: flex; align-items: center; gap: 10px; color: #aaa; font-size: 13px; margin: 16px 0; }
    .or-row::before, .or-row::after { content: ''; flex: 1; border-top: 1px solid #eee; }

    /* Join row */
    .join-row { display: flex; gap: 8px; }
    .join-row input { flex: 1; }
    .join-row .btn { width: auto; white-space: nowrap; }

    /* Row utils */
    .row { display: flex; gap: 8px; }
    .row .btn { flex: 1; }

    /* Modal */
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,.45); z-index: 200; display: flex; align-items: flex-end; }
    .modal { background: #fff; border-radius: 16px 16px 0 0; padding: 20px 16px 32px; width: 100%; max-height: 85vh; overflow-y: auto; }
    .modal-title { font-size: 15px; font-weight: 700; text-align: center; margin-bottom: 4px; }
    .modal-players { display: flex; justify-content: space-between; align-items: center; font-size: 16px; font-weight: 700; margin-bottom: 18px; }
    .modal-vs { color: #aaa; font-size: 13px; font-weight: 400; }
    .set-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
    .set-label { font-size: 13px; color: #888; min-width: 38px; }
    .set-input { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; text-align: center; }
    .set-input:focus { border-color: #e74c3c; outline: none; }
    .set-rm { background: #eee; border: none; border-radius: 6px; padding: 9px 11px; font-size: 13px; cursor: pointer; color: #888; }
    .score-display { font-size: 24px; font-weight: 700; text-align: center; margin: 12px 0; color: #e74c3c; }
    .modal-actions { display: flex; gap: 8px; margin-top: 16px; }
    .modal-actions .btn { flex: 1; }
  </style>
</head>
<body>
<div id="app"></div>
<script>
'use strict';

// ================================================================
// STATE
// ================================================================
let S = {
  screen: 'setup',
  tab: 'matches',
  settings: {
    gameType: 'singles',
    doublesMode: 'auto',
    scoringFormat: 'bo3',
    tournamentType: 'roundrobin',
    playerCount: 4,
  },
  players: [],
  teams: [],
  matches: [],
  modalMatchId: null,
};

let roomCode = null;
let pollTimer = null;
let matchIdSeed = 0;

// ================================================================
// API
// ================================================================
async function apiCreate() {
  const res = await fetch('/api/rooms', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ state: S }),
  });
  return (await res.json()).code;
}

async function apiGet(code) {
  const res = await fetch(`/api/rooms/${code}`);
  if (!res.ok) return null;
  return res.json();
}

function apiSave(code, state) {
  fetch(`/api/rooms/${code}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ state }),
  }).catch(() => {});
}

// ================================================================
// POLLING
// ================================================================
function startPolling() {
  if (pollTimer) return;
  pollTimer = setInterval(async () => {
    if (!roomCode || S.modalMatchId !== null) return;
    const room = await apiGet(roomCode);
    if (!room) return;
    if (JSON.stringify(room.state) !== JSON.stringify(S)) {
      Object.assign(S, room.state);
      render();
    }
  }, 5000);
}

function stopPolling() {
  clearInterval(pollTimer);
  pollTimer = null;
}

// ================================================================
// MATCH GENERATION HELPERS
// ================================================================
function mkMatch(o) {
  return {
    id: ++matchIdSeed,
    type: 'singles', phase: 'roundrobin', round: 1,
    player1: '', player2: '', p1id: null, p2id: null,
    winner: null, score1: 0, score2: 0, sets: [],
    isBye: false, pending: false, referee: null,
    ...o,
  };
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// Circle-method round robin ‚Üí returns array of rounds
function rrSchedule(items) {
  let list = [...items];
  if (list.length % 2 === 1) list.push(null); // bye slot
  const n = list.length;
  const rounds = [];
  const fixed = list[0];
  let rot = list.slice(1);
  for (let r = 0; r < n - 1; r++) {
    const cur = [fixed, ...rot];
    const round = [];
    for (let i = 0; i < n / 2; i++) {
      const a = cur[i], b = cur[n - 1 - i];
      if (a && b) round.push([a, b]);
    }
    rounds.push(round);
    rot = [rot[rot.length - 1], ...rot.slice(0, -1)];
  }
  return rounds;
}

function genRoundRobin(players, type = 'singles') {
  const rounds = rrSchedule(players);
  const matches = [];
  rounds.forEach((round, ri) => {
    round.forEach(([p1, p2]) => {
      matches.push(mkMatch({
        type, phase: 'roundrobin', round: ri + 1,
        player1: p1.name, player2: p2.name, p1id: p1.id, p2id: p2.id,
      }));
    });
  });
  return matches;
}

function genTournament(players, type = 'singles') {
  const shuffled = shuffle(players);
  const rounds = Math.ceil(Math.log2(shuffled.length));
  const slots = Math.pow(2, rounds);
  const seeded = [...shuffled];
  while (seeded.length < slots) seeded.push(null);

  const matches = [];

  // Round 1
  for (let i = 0; i < slots / 2; i++) {
    const p1 = seeded[i * 2], p2 = seeded[i * 2 + 1];
    const bye = !p1 || !p2;
    const winner = bye ? (p1 || p2) : null;
    matches.push(mkMatch({
      type, phase: 'tournament', round: 1,
      player1: p1 ? p1.name : 'BYE', player2: p2 ? p2.name : 'BYE',
      p1id: p1 ? p1.id : -1, p2id: p2 ? p2.id : -1,
      winner: winner ? winner.name : null, isBye: bye,
    }));
  }

  // Later rounds (placeholders)
  let prev = slots / 2;
  for (let r = 2; r <= rounds; r++) {
    const cnt = prev / 2;
    for (let i = 0; i < cnt; i++) {
      matches.push(mkMatch({ type, phase: 'tournament', round: r, player1: '?', player2: '?', pending: true }));
    }
    prev = cnt;
  }

  advanceTournament(matches);
  return matches;
}

function advanceTournament(matches) {
  const byRound = {};
  matches.filter(m => m.phase === 'tournament').forEach(m => {
    (byRound[m.round] = byRound[m.round] || []).push(m);
  });
  const rounds = Object.keys(byRound).map(Number).sort((a, b) => a - b);
  for (let i = 0; i < rounds.length - 1; i++) {
    const cur = byRound[rounds[i]];
    const nxt = byRound[rounds[i + 1]];
    for (let j = 0; j < cur.length; j += 2) {
      const m1 = cur[j], m2 = cur[j + 1];
      const nm = nxt[Math.floor(j / 2)];
      if (!nm) continue;
      if (m1?.winner) { nm.player1 = m1.winner; nm.p1id = m1.winner === m1.player1 ? m1.p1id : m1.p2id; }
      if (m2?.winner) { nm.player2 = m2.winner; nm.p2id = m2.winner === m2.player1 ? m2.p1id : m2.p2id; }
      if (nm.player1 !== '?' && nm.player2 !== '?') nm.pending = false;
    }
  }
}

function genDoubles(players, doublesMode, tournamentType) {
  let teams = S.teams;
  if (doublesMode === 'auto') {
    const sh = shuffle(players);
    teams = [];
    for (let i = 0; i < Math.floor(sh.length / 2); i++) {
      const a = sh[i * 2], b = sh[i * 2 + 1];
      teams.push({ id: i + 1, p1id: a.id, p2id: b.id, p1: a.name, p2: b.name, name: `${a.name} / ${b.name}` });
    }
  }
  const tp = teams.map(t => ({ id: t.id, name: t.name }));
  const matches = tournamentType === 'roundrobin'
    ? genRoundRobin(tp, 'doubles')
    : genTournament(tp, 'doubles');
  return { teams, matches };
}

function genJjampong(players) {
  // Singles: full round robin
  const singles = genRoundRobin(players, 'singles');
  singles.forEach(m => { m.phase = 'singles'; });

  // Doubles: 3 rounds with rotating random pairings
  const doubles = [];
  const n = players.length;
  const numRounds = n % 2 === 1 ? n : Math.max(3, Math.floor(n / 2));

  for (let r = 0; r < numRounds; r++) {
    let referee = null;
    let pool = [...players];

    if (n % 2 === 1) {
      referee = players[r % n];
      pool = players.filter(p => p.id !== referee.id);
    }

    const sh = shuffle(pool);
    for (let i = 0; i + 3 < sh.length; i += 4) {
      doubles.push(mkMatch({
        type: 'doubles', phase: 'doubles', round: r + 1,
        player1: `${sh[i].name} / ${sh[i + 1].name}`,
        player2: `${sh[i + 2].name} / ${sh[i + 3].name}`,
        referee: referee ? referee.name : null,
      }));
    }
  }

  return [...singles, ...doubles];
}

// ================================================================
// SCORING
// ================================================================
function winsNeeded() {
  return S.settings.scoringFormat === 'bo5' ? 3 : 2;
}

function countSets(sets) {
  let s1 = 0, s2 = 0;
  sets.forEach(([a, b]) => {
    const ia = parseInt(a) || 0, ib = parseInt(b) || 0;
    if (ia > ib) s1++; else if (ib > ia) s2++;
  });
  return { s1, s2 };
}

// ================================================================
// DOM HELPERS
// ================================================================
function h(tag, props = {}, ...children) {
  const el = document.createElement(tag);
  Object.entries(props).forEach(([k, v]) => {
    if (k === 'cls') el.className = v;
    else if (k.startsWith('on')) el[k] = v;
    else if (k === 'html') el.innerHTML = v;
    else el.setAttribute(k, v);
  });
  children.flat(Infinity).forEach(c => {
    if (c == null) return;
    el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
  });
  return el;
}

const d = (cls, ...children) => h('div', { cls }, ...children);
const s = (cls, text) => h('span', { cls }, text);

// ================================================================
// RENDER DISPATCHER
// ================================================================
const app = document.getElementById('app');

function render() {
  app.innerHTML = '';
  if (S.screen === 'setup') renderSetup();
  else if (S.screen === 'players') renderPlayers();
  else renderMain();
}

// ================================================================
// SETUP SCREEN
// ================================================================
function renderSetup() {
  let showNew = false;
  let tmp = { ...S.settings };

  const draw = () => {
    app.innerHTML = '';
    app.appendChild(d('header', h('h1', {}, 'üèì ÌÉÅÍµ¨ ÎåÄÏßÑÌëú')));

    if (!showNew) {
      const codeInput = h('input', { type: 'text', placeholder: 'Î∞© ÏΩîÎìú ÏûÖÎ†• (Ïòà: ABF3K7)', style: 'text-transform:uppercase;letter-spacing:2px' });
      app.appendChild(d('content',
        d('hero',
          d('hero-icon', 'üèì'),
          d('hero-title', 'ÌÉÅÍµ¨ ÎåÄÏßÑÌëú'),
          d('hero-sub', 'ÏπúÍµ¨Îì§Í≥º Ìï®ÍªòÌïòÎäî ÌÉÅÍµ¨ ÎåÄÌöå'),
        ),
        h('button', { cls: 'btn btn-primary', onclick: () => { showNew = true; draw(); } }, 'ÏÉà ÎåÄÌöå ÎßåÎì§Í∏∞'),
        d('or-row', 'ÎòêÎäî Î∞© ÏΩîÎìúÎ°ú Ï∞∏Í∞Ä'),
        d('join-row',
          codeInput,
          h('button', {
            cls: 'btn btn-secondary btn-sm',
            onclick: async () => {
              const code = codeInput.value.trim().toUpperCase();
              if (code.length !== 6) { alert('6ÏûêÎ¶¨ Î∞© ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî'); return; }
              const room = await apiGet(code);
              if (!room) { alert('Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.\nÏÑúÎ≤ÑÍ∞Ä Ïû¨ÏãúÏûëÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'); return; }
              roomCode = code;
              Object.assign(S, room.state);
              history.replaceState(null, '', `?room=${code}`);
              startPolling();
              render();
            }
          }, 'Ï∞∏Í∞Ä'),
        ),
      ));
      return;
    }

    // New tournament settings
    const optGroup = (options, key) =>
      d('option-group', ...options.map(({ value, label }) => {
        const b = d(`opt-btn${tmp[key] === value ? ' active' : ''}`, label);
        b.onclick = () => { tmp[key] = value; draw(); };
        return b;
      }));

    const countSel = h('select', { onchange: e => { tmp.playerCount = parseInt(e.target.value); } },
      ...[...Array(15)].map((_, i) => {
        const n = i + 2;
        const o = h('option', { value: n }, `${n}Î™Ö`);
        if (tmp.playerCount === n) o.selected = true;
        return o;
      })
    );

    const fields = [
      d('form-group', h('label', {}, 'Ï¢ÖÎ™©'), optGroup([{ value: 'singles', label: 'Îã®Ïãù' }, { value: 'doubles', label: 'Î≥µÏãù' }, { value: 'jjampong', label: 'ÌòºÌï© Î¶¥Î†àÏù¥' }], 'gameType')),
      d('form-group', h('label', {}, 'ÎìùÏ†ê Î∞©Ïãù'), optGroup([{ value: 'bo3', label: '3Ìåê2Ïäπ' }, { value: 'bo5', label: '5Ìåê3Ïäπ' }], 'scoringFormat')),
    ];

    if (tmp.gameType !== 'jjampong') {
      fields.push(d('form-group', h('label', {}, 'Í≤ΩÍ∏∞ Î∞©Ïãù'), optGroup([{ value: 'roundrobin', label: 'Î¶¨Í∑∏Ï†Ñ' }, { value: 'tournament', label: 'ÌÜ†ÎÑàÎ®ºÌä∏' }], 'tournamentType')));
    }
    if (tmp.gameType === 'doubles') {
      fields.push(d('form-group', h('label', {}, 'ÌåÄ Íµ¨ÏÑ±'), optGroup([{ value: 'auto', label: 'ÏûêÎèô Îß§Ïπ≠' }, { value: 'manual', label: 'ÏßÅÏ†ë Íµ¨ÏÑ±' }], 'doublesMode')));
    }
    fields.push(d('form-group', h('label', {}, 'Ï∞∏Í∞Ä Ïù∏Ïõê'), countSel));

    app.appendChild(d('content',
      d('row',
        h('button', { cls: 'btn btn-secondary btn-sm', style: 'width:auto', onclick: () => { showNew = false; draw(); } }, '‚Üê Îí§Î°ú'),
        h('h2', { style: 'font-size:15px;font-weight:700;line-height:37px' }, 'ÏÉà ÎåÄÌöå ÏÑ§Ï†ï'),
      ),
      h('div', { style: 'height:12px' }),
      ...fields,
      h('button', {
        cls: 'btn btn-primary',
        onclick: () => {
          S.settings = { ...tmp };
          S.players = Array.from({ length: tmp.playerCount }, (_, i) => ({ id: i + 1, name: `ÏÑ†Ïàò${i + 1}` }));
          S.teams = []; S.matches = []; S.screen = 'players';
          render();
        }
      }, 'Îã§Ïùå ‚Üí ÏÑ†Ïàò Îì±Î°ù'),
    ));
  };

  draw();
}

// ================================================================
// PLAYERS SCREEN
// ================================================================
function renderPlayers() {
  const players = S.players.map(p => ({ ...p }));
  const { gameType, doublesMode, playerCount } = S.settings;
  let teams = S.teams.length > 0 ? S.teams.map(t => ({ ...t })) :
    (gameType === 'doubles' && doublesMode === 'manual')
      ? Array.from({ length: Math.floor(playerCount / 2) }, (_, i) => ({ id: i + 1, p1id: null, p2id: null, p1: '', p2: '', name: '' }))
      : [];

  const draw = () => {
    app.innerHTML = '';
    app.appendChild(d('header', h('h1', {}, 'ÏÑ†Ïàò Îì±Î°ù')));

    const playerInputs = players.map((p, i) => {
      const inp = h('input', { type: 'text', value: p.name, placeholder: `ÏÑ†Ïàò ${i + 1}` });
      inp.oninput = e => { players[i].name = e.target.value || `ÏÑ†Ïàò${i + 1}`; };
      return d('player-row', s('player-num', `${i + 1}.`), inp);
    });

    let teamSection = null;
    if (gameType === 'doubles' && doublesMode === 'manual') {
      const mkSel = (selectedId, onChange) => {
        const sel = h('select', { onchange: e => onChange(parseInt(e.target.value) || null) },
          h('option', { value: '' }, 'ÏÑ†Ïàò ÏÑ†ÌÉù'),
          ...players.map(p => {
            const o = h('option', { value: p.id }, p.name);
            if (p.id === selectedId) o.selected = true;
            return o;
          })
        );
        return sel;
      };

      const cards = teams.map((team, ti) => d('team-card',
        h('h4', {}, `ÌåÄ ${ti + 1}`),
        d('team-selects',
          mkSel(team.p1id, id => {
            teams[ti].p1id = id;
            teams[ti].p1 = players.find(p => p.id === id)?.name || '';
            teams[ti].name = `${teams[ti].p1} / ${teams[ti].p2}`;
          }),
          s('', ' / '),
          mkSel(team.p2id, id => {
            teams[ti].p2id = id;
            teams[ti].p2 = players.find(p => p.id === id)?.name || '';
            teams[ti].name = `${teams[ti].p1} / ${teams[ti].p2}`;
          }),
        )
      ));
      teamSection = h('div', { style: 'margin-top:16px' }, h('label', {}, 'ÌåÄ Íµ¨ÏÑ±'), ...cards);
    }

    app.appendChild(d('content',
      ...playerInputs,
      teamSection,
      h('div', { style: 'height:16px' }),
      d('row',
        h('button', { cls: 'btn btn-secondary', onclick: () => { S.screen = 'setup'; render(); } }, '‚Üê Îí§Î°ú'),
        h('button', {
          cls: 'btn btn-primary',
          onclick: async () => {
            S.players = players;
            matchIdSeed = 0;
            const { gameType: gt, scoringFormat, tournamentType, doublesMode: dm } = S.settings;

            if (gt === 'doubles' && S.players.length % 2 !== 0) {
              alert(`Î≥µÏãùÏùÄ ÏßùÏàò Ïù∏ÏõêÎßå Í∞ÄÎä•Ìï©ÎãàÎã§.\nÌòÑÏû¨ ${S.players.length}Î™Ö ‚Üí ${S.players.length + 1}Î™Ö ÎòêÎäî ${S.players.length - 1}Î™ÖÏúºÎ°ú Î≥ÄÍ≤ΩÌï¥Ï£ºÏÑ∏Ïöî.`);
              return;
            }

            if (gt === 'singles') {
              S.matches = tournamentType === 'roundrobin' ? genRoundRobin(S.players) : genTournament(S.players);
            } else if (gt === 'doubles') {
              if (dm === 'manual') S.teams = teams; // ÏßÅÏ†ëÍµ¨ÏÑ± ÌåÄ Î®ºÏ†Ä Ï†ÄÏû•
              const r = genDoubles(S.players, dm, tournamentType);
              S.teams = r.teams; S.matches = r.matches;
            } else {
              S.matches = genJjampong(S.players);
            }

            S.screen = 'main'; S.tab = 'matches';
            const code = await apiCreate();
            roomCode = code;
            history.replaceState(null, '', `?room=${code}`);
            startPolling();
            render();
          }
        }, 'ÎåÄÏßÑÌëú ÏÉùÏÑ± ‚Üí'),
      ),
    ));
  };

  draw();
}

// ================================================================
// MAIN SCREEN
// ================================================================
function renderMain() {
  app.innerHTML = '';

  // Header
  const shareBtn = h('button', {
    cls: 'icon-btn',
    onclick: () => {
      const url = location.href;
      if (navigator.clipboard) navigator.clipboard.writeText(url).then(() => alert('ÎßÅÌÅ¨ Î≥µÏÇ¨Îê®!'));
      else prompt('ÎßÅÌÅ¨Î•º Î≥µÏÇ¨ÌïòÏÑ∏Ïöî:', url);
    }
  }, 'üîó');

  const headerRight = d('header-right',
    roomCode ? s('room-chip', roomCode) : null,
    shareBtn,
  );
  app.appendChild(d('header', h('h1', {}, 'üèì ÌÉÅÍµ¨ ÎåÄÏßÑÌëú'), headerRight));

  // Tabs
  const tabDefs = [['matches', 'Í≤ΩÍ∏∞'], ['bracket', 'ÎåÄÏßÑÌëú'], ['info', 'Ï†ïÎ≥¥']];
  app.appendChild(d('tabs', ...tabDefs.map(([key, label]) => {
    const t = d(`tab${S.tab === key ? ' active' : ''}`, label);
    t.onclick = () => { S.tab = key; renderMain(); };
    return t;
  })));

  // Tab content
  if (S.tab === 'matches') app.appendChild(renderMatchesTab());
  else if (S.tab === 'bracket') app.appendChild(renderBracketTab());
  else app.appendChild(renderInfoTab());

  // Modal
  if (S.modalMatchId !== null) app.appendChild(renderModal());
}

// ================================================================
// MATCHES TAB
// ================================================================
function roundLabel(phase, round, totalInRound) {
  if (phase === 'singles') return `Îã®Ïãù ${round}ÎùºÏö¥Îìú`;
  if (phase === 'doubles') return `Î≥µÏãù ${round}ÎùºÏö¥Îìú`;
  if (phase === 'roundrobin') return `${round}ÎùºÏö¥Îìú`;
  if (phase === 'tournament') {
    if (totalInRound === 1) return 'Í≤∞Ïäπ';
    if (totalInRound === 2) return 'Ï§ÄÍ≤∞Ïäπ';
    if (totalInRound === 4) return '8Í∞ï';
    return `ÌÜ†ÎÑàÎ®ºÌä∏ ${round}ÎùºÏö¥Îìú`;
  }
  return `${round}ÎùºÏö¥Îìú`;
}

function renderMatchesTab() {
  const content = d('content');

  // Winner banner for single-elim
  if (S.settings.tournamentType === 'tournament' && S.settings.gameType !== 'jjampong') {
    const lastRound = Math.max(...S.matches.filter(m => m.phase === 'tournament').map(m => m.round));
    const final = S.matches.find(m => m.phase === 'tournament' && m.round === lastRound);
    if (final?.winner && final.winner !== '?') {
      content.appendChild(d('winner-banner',
        d('trophy', 'üèÜ'), d('wname', final.winner), d('wlabel', 'Ïö∞Ïäπ')
      ));
    }
  }

  // Group by phase+round
  const groups = {};
  S.matches.forEach(m => {
    const key = `${m.phase}__${m.round}`;
    if (!groups[key]) groups[key] = { phase: m.phase, round: m.round, list: [] };
    groups[key].list.push(m);
  });

  const phaseOrder = { singles: 0, roundrobin: 0, tournament: 1, doubles: 2 };
  Object.keys(groups).sort((a, b) => {
    const ga = groups[a], gb = groups[b];
    return (phaseOrder[ga.phase] || 0) - (phaseOrder[gb.phase] || 0) || ga.round - gb.round;
  }).forEach(key => {
    const { phase, round, list } = groups[key];
    content.appendChild(d('round-label', roundLabel(phase, round, list.length)));
    list.forEach(m => content.appendChild(matchCard(m)));
  });

  return content;
}

function matchCard(m) {
  const done = !!m.winner;
  let cls = 'match-card';
  if (done && !m.isBye) cls += ' done';
  if (m.isBye) cls += ' bye';
  if (m.pending) cls += ' pending';

  const card = d(cls);

  if (m.isBye) {
    const winner = m.player1 === 'BYE' ? m.player2 : m.player1;
    card.appendChild(d('match-players',
      h('div', { cls: 'mp' }, winner),
      s('match-vs', 'Î∂ÄÏ†ÑÏäπ'),
      h('div', { cls: 'mp right', style: 'color:#ccc' }, 'BYE'),
    ));
    return card;
  }

  if (m.pending) {
    card.appendChild(d('match-players',
      h('div', { cls: 'mp', style: 'color:#ccc' }, '?'),
      s('match-vs', 'vs'),
      h('div', { cls: 'mp right', style: 'color:#ccc' }, '?'),
    ));
    return card;
  }

  const p1cls = `mp${m.winner === m.player1 ? ' winner' : ''}`;
  const p2cls = `mp right${m.winner === m.player2 ? ' winner' : ''}`;
  const vsLabel = done ? `${m.score1}-${m.score2}` : 'vs';

  card.appendChild(d('match-players',
    h('div', { cls: p1cls }, m.player1),
    s('match-vs', vsLabel),
    h('div', { cls: p2cls }, m.player2),
  ));

  if (m.referee) {
    card.appendChild(d('ref-note', 'Ïã¨Ìåê:', h('span', { cls: 'ref-badge' }, m.referee)));
  }

  if (m.sets?.length > 0) {
    const setsEl = d('match-sets');
    const { s1, s2 } = countSets(m.sets);
    let c1 = 0, c2 = 0;
    m.sets.forEach(([a, b]) => {
      const ia = parseInt(a) || 0, ib = parseInt(b) || 0;
      const p1wins = ia > ib;
      if (p1wins) c1++; else c2++;
      setsEl.appendChild(s(`set-pill${p1wins ? ' w' : ''}`, `${a}-${b}`));
    });
    card.appendChild(setsEl);
  }

  card.onclick = () => {
    S.modalMatchId = m.id;
    stopPolling();
    renderMain();
  };

  return card;
}

// ================================================================
// BRACKET TAB
// ================================================================
function renderBracketTab() {
  const content = d('content');
  const { gameType, tournamentType } = S.settings;

  if (gameType === 'jjampong') {
    // Îã®Ïãù ÏàúÏúÑ
    content.appendChild(h('div', { style: 'font-size:13px;font-weight:700;color:#888;margin-bottom:8px' }, 'Îã®Ïãù ÏàúÏúÑ'));
    content.appendChild(renderStandings('singles'));

    // Î≥µÏãù Í≤∞Í≥º
    const dMatches = S.matches.filter(m => m.phase === 'doubles' && m.winner);
    if (dMatches.length > 0) {
      content.appendChild(h('div', { style: 'font-size:13px;font-weight:700;color:#888;margin:16px 0 8px' }, 'Î≥µÏãù Í≤∞Í≥º'));
      const grouped = {};
      dMatches.forEach(m => { (grouped[m.round] = grouped[m.round] || []).push(m); });
      Object.keys(grouped).sort((a,b) => a-b).forEach(r => {
        content.appendChild(d('round-label', `Î≥µÏãù ${r}ÎùºÏö¥Îìú`));
        grouped[r].forEach(m => content.appendChild(matchCard(m)));
      });
    }
    return content;
  }

  if (tournamentType === 'tournament') {
    const tournMatches = S.matches.filter(m => m.phase === 'tournament');
    const maxRound = Math.max(...tournMatches.map(m => m.round));
    const wrap = d('bracket-wrap');
    const rounds = d('bracket-rounds');

    for (let r = 1; r <= maxRound; r++) {
      const rm = tournMatches.filter(m => m.round === r);
      const col = d('bracket-col');
      col.appendChild(d('bracket-col-label', roundLabel('tournament', r, rm.length)));
      rm.forEach(m => {
        const bm = d(`bracket-match${m.winner ? ' done' : ''}`);
        const p1cls = `bp${m.player1 === 'BYE' || m.player1 === '?' ? ' bye' : m.winner === m.player1 ? ' winner' : ''}`;
        const p2cls = `bp${m.player2 === 'BYE' || m.player2 === '?' ? ' bye' : m.winner === m.player2 ? ' winner' : ''}`;
        bm.appendChild(h('div', { cls: p1cls }, m.player1 || '?'));
        bm.appendChild(h('hr', { cls: 'bdivider' }));
        bm.appendChild(h('div', { cls: p2cls }, m.player2 || '?'));
        col.appendChild(bm);
      });
      rounds.appendChild(col);
    }
    wrap.appendChild(rounds);
    content.appendChild(wrap);
  } else {
    content.appendChild(renderStandings());
  }

  return content;
}

function renderStandings(forceType) {
  const gameType = forceType || S.settings.gameType;
  const items = gameType === 'doubles'
    ? S.teams.map(t => ({ id: t.id, name: t.name }))
    : S.players;

  const stats = {};
  items.forEach(p => { stats[p.name] = { name: p.name, w: 0, l: 0, sw: 0, sl: 0, pts: 0 }; });

  S.matches.filter(m => m.winner && !m.isBye && (m.phase === 'roundrobin' || m.phase === 'singles')).forEach(m => {
    if (!stats[m.player1] || !stats[m.player2]) return;
    const win = m.winner, lose = m.winner === m.player1 ? m.player2 : m.player1;
    stats[win].w++; stats[win].pts += 2; stats[lose].l++;
    stats[win].sw += m.score1 > m.score2 ? m.score1 : m.score2;
    stats[win].sl += m.score1 > m.score2 ? m.score2 : m.score1;
    stats[lose].sw += m.score1 > m.score2 ? m.score2 : m.score1;
    stats[lose].sl += m.score1 > m.score2 ? m.score1 : m.score2;
  });

  const sorted = Object.values(stats).sort((a, b) => b.pts - a.pts || b.w - a.w || (b.sw - b.sl) - (a.sw - a.sl));

  return h('table', { cls: 'standings-table' },
    h('thead', {}, h('tr', {},
      h('th', {}, '#'), h('th', {}, 'Ïù¥Î¶Ñ'), h('th', {}, 'ÏäπÏ†ê'), h('th', {}, 'Ïäπ'), h('th', {}, 'Ìå®'), h('th', {}, 'ÏÑ∏Ìä∏'),
    )),
    h('tbody', {}, ...sorted.map((p, i) => h('tr', {},
      h('td', { cls: 'rank' }, `${i + 1}`),
      h('td', {}, p.name),
      h('td', { style: 'font-weight:700;color:#e74c3c' }, `${p.pts}`),
      h('td', {}, `${p.w}`),
      h('td', {}, `${p.l}`),
      h('td', {}, `${p.sw}-${p.sl}`),
    ))),
  );
}

// ================================================================
// INFO TAB
// ================================================================
function renderInfoTab() {
  const content = d('content');
  const { gameType, scoringFormat, tournamentType } = S.settings;
  const total = S.matches.filter(m => !m.isBye && !m.pending).length;
  const done = S.matches.filter(m => m.winner && !m.isBye).length;

  if (roomCode) {
    content.appendChild(d('',
      h('label', {}, 'Î∞© ÏΩîÎìú'),
      d('room-code-big', roomCode),
      h('p', { style: 'text-align:center;font-size:12px;color:#aaa;margin-bottom:16px' }, 'URL ÎòêÎäî Ïù¥ ÏΩîÎìúÎ°ú Ï∞∏Í∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§'),
    ));
  }

  content.appendChild(d('info-box',
    h('h3', {}, 'ÎåÄÌöå Ï†ïÎ≥¥'),
    d('info-row', h('span', {}, 'Ï¢ÖÎ™©'), s('info-val', gameType === 'singles' ? 'Îã®Ïãù' : gameType === 'doubles' ? 'Î≥µÏãù' : 'Îã®Ïãù+Î≥µÏãù ÌòºÌï© Î¶¥Î†àÏù¥')),
    d('info-row', h('span', {}, 'ÎìùÏ†ê'), s('info-val', scoringFormat === 'bo3' ? '3Ìåê2Ïäπ' : '5Ìåê3Ïäπ')),
    d('info-row', h('span', {}, 'Î∞©Ïãù'), s('info-val', gameType === 'jjampong' ? 'Îã®Ïãù+Î≥µÏãù ÌòºÌï© Î¶¥Î†àÏù¥' : tournamentType === 'roundrobin' ? 'Î¶¨Í∑∏Ï†Ñ' : 'ÌÜ†ÎÑàÎ®ºÌä∏')),
    d('info-row', h('span', {}, 'Ï∞∏Í∞ÄÏûê'), s('info-val', `${S.players.length}Î™Ö`)),
    d('info-row', h('span', {}, 'ÏßÑÌñâ'), s('info-val', `${done} / ${total} Í≤ΩÍ∏∞`)),
  ));

  content.appendChild(d('info-box',
    h('h3', {}, 'Ï∞∏Í∞ÄÏûê'),
    ...S.players.map((p, i) => d('info-row', h('span', {}, `${i + 1}. ${p.name}`))),
  ));

  return content;
}

// ================================================================
// SCORE MODAL
// ================================================================
function renderModal() {
  const match = S.matches.find(m => m.id === S.modalMatchId);
  if (!match) return null;

  const maxSets = S.settings.scoringFormat === 'bo5' ? 5 : 3;
  const needed = winsNeeded();
  let sets = match.sets.length > 0 ? match.sets.map(s => [...s]) : [['', '']];

  const overlay = d('overlay');

  const draw = () => {
    overlay.innerHTML = '';
    const modal = d('modal');

    modal.appendChild(d('modal-title', 'Ï†êÏàò ÏûÖÎ†•'));
    modal.appendChild(d('modal-players',
      h('span', {}, match.player1),
      s('modal-vs', 'vs'),
      h('span', {}, match.player2),
    ));

    // Set rows
    sets.forEach((set, i) => {
      const in1 = h('input', { type: 'number', cls: 'set-input', value: set[0], min: '0' });
      const in2 = h('input', { type: 'number', cls: 'set-input', value: set[1], min: '0' });
      in1.oninput = e => { sets[i][0] = e.target.value; };
      in2.oninput = e => { sets[i][1] = e.target.value; };

      const row = d('set-row', s('set-label', `${i + 1}ÏÑ∏Ìä∏`), in1, s('', ' - '), in2);

      if (i === sets.length - 1 && sets.length > 1) {
        const rmBtn = h('button', { cls: 'set-rm', onclick: () => { sets.pop(); draw(); } }, '‚úï');
        row.appendChild(rmBtn);
      }
      modal.appendChild(row);
    });

    // Score summary
    const { s1, s2 } = countSets(sets.filter(([a, b]) => a !== '' || b !== ''));
    modal.appendChild(d('score-display', `${s1} - ${s2}`));

    // Add set button
    const canAdd = s1 < needed && s2 < needed && sets.length < maxSets;
    if (canAdd) {
      modal.appendChild(h('button', {
        cls: 'btn btn-secondary', style: 'margin-bottom:8px',
        onclick: () => { sets.push(['', '']); draw(); }
      }, '+ ÏÑ∏Ìä∏ Ï∂îÍ∞Ä'));
    }

    // Actions
    modal.appendChild(d('modal-actions',
      h('button', {
        cls: 'btn btn-secondary',
        onclick: () => { S.modalMatchId = null; startPolling(); renderMain(); }
      }, 'Ï∑®ÏÜå'),
      h('button', {
        cls: 'btn btn-primary',
        onclick: () => {
          const filled = sets.filter(([a, b]) => a !== '' && b !== '');
          if (!filled.length) { alert('ÏµúÏÜå 1ÏÑ∏Ìä∏Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî'); return; }
          const { s1, s2 } = countSets(filled);
          let winner = null;
          if (s1 >= needed) winner = match.player1;
          else if (s2 >= needed) winner = match.player2;
          if (!winner) { alert(`${needed}ÏÑ∏Ìä∏Î•º Î®ºÏ†Ä Ïù¥Í≤®Ïïº ÏôÑÎ£åÎê©ÎãàÎã§`); return; }

          const idx = S.matches.findIndex(m => m.id === S.modalMatchId);
          S.matches[idx] = { ...match, sets: filled, score1: s1, score2: s2, winner };

          if (match.phase === 'tournament') advanceTournament(S.matches);

          S.modalMatchId = null;
          if (roomCode) apiSave(roomCode, S);
          startPolling();
          renderMain();
        }
      }, 'Ï†ÄÏû•'),
    ));

    overlay.appendChild(modal);
  };

  draw();

  overlay.onclick = e => {
    if (e.target === overlay) { S.modalMatchId = null; startPolling(); renderMain(); }
  };

  return overlay;
}

// ================================================================
// INIT
// ================================================================
window.onload = async () => {
  const code = new URLSearchParams(location.search).get('room');
  if (code) {
    const room = await apiGet(code);
    if (room) {
      roomCode = code;
      Object.assign(S, room.state);
      startPolling();
    } else {
      alert('Î∞©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.\nÏÑúÎ≤ÑÍ∞Ä Ïû¨ÏãúÏûëÎêòÏóàÏùÑ Ïàò ÏûàÏäµÎãàÎã§.');
      history.replaceState(null, '', '/');
    }
  }
  render();
};
</script>
</body>
</html>
